*오래된 스크립트를 읽을 때 도움을 주는 글 

<h2>오래된 var</h2>

<h3>var는 블록 스코프가 없다.</h3>

`var`로 선언한 변수의 스코프는 함수 스코프이거나 전역 스코프이다. 블록 기준으로 스코프가 생기지 않기 때문에 블록 밖에서 접근 가능하다. 
```
if (true) {
	var test = true;
}
alert(test); //true
```

<h3>var는 변수의 중복 선언을 허용한다.</h3>

한 스코프에서 같은 변수를 `let`으로 두 번 선언하면 에러가 발생한다. 하지만 `var`로는 같은 변수를 여러 번 중복으로 선언할 수 있다. 이미 선언된 변수에 `var`를 사용하면 두 번째 선언문은 무시된다. 

<h3>선언하기 전 사용할 수 있는 var</h3>

`var` 선언은 <u>함수가 시작될 때</u> 처리된다. 전역으로 선언한 변수라면 스크립트가 시작될 때 처리되고, 함수 본문 내에서 선언한 변수는 선언 위치와 상관없이 함수 본문이 시작되는 지점에서 정의된다. 

따라서 아래 예제는 모두 동일하게 동작한다.
```
function sayHi() {
	phrase = "Hello";
	alert(phrase);
	var phrase;
}
```
```
function sayHi() {
	var phrase;
	phrase = "Hello";
	alert(phrase);
}
```
```
function sayHi() {
	phrase = "Hello";
	if (false) {
		var phrase;
	}
	alert(phrase);
}
```
이렇게 변수가 끌어올려 지는 현상을 '호이스팅(hoisting)'이라고 부른다. `var`로 선언한 모든 변수는 함수의 최상위로 '끌어 올려지기(hoisted)' 때문이다. 

<u>선언은 호이스팅 되지만 할당은 호이스팅 되지 않는다.</u> 모든 `var` 선언은 함수 시작 시 처리되기 때문에, `var`로 선언한 변수는 어디서든 참조할 수 있다. 하지만 변수에 무언가를 할당하기 전까진 값이 `undefined`이다. 

<br>
<h2>즉시 실행 함수 표현식</h2>

`var`가 블록 레벨 스코프를 가질 수 있게 여러가지 방안을 고려하다 만들어진 것이 '즉시 실행 함수 표현식(IIFE)'이다.

IIFE는 다음과 같이 생겼다. 함수를 괄호로 감싸면 자바스크립트가 함수를 함수 선언문이 아닌 표현식으로 인식하도록 속일 수 있다. 함수 표현식은 이름이 없어도 괜찮고, 즉시 호출도 가능하다.
```
(function() {
	let message = "Hello";
	alert(message); //Hello
})();
```
- 함수 표현식이 만들어지고 바로 호출되면서, 해당 함수가 바로 실행된다. 

괄호를 사용하는 방법 말고도, 자바스크립트가 함수 표현식이라고 인식하게 해주는 다른 방법들이 있다.
```
(function() {
	alert('함수를 괄호로 둘러싸기');
})();

(function() {
	alert('전체를 괄호로 둘러싸기');
}());

!function() {
	alert('표현식 앞에 비트 NOT 연산자 붙이기');
}();

+function() {
	alert('표현식 앞에 단항 덧셈 연산자 붙이기');
}();
```

<br>
<h2>참고</h2>

모던 JavaScript 튜토리얼
