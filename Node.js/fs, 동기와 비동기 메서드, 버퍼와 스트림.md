### fs

- 파일 시스템에 접근하는 모듈 
- 파일/폴더 생성, 삭제, 읽기, 쓰기 가능 
- 웹 브라우저에서는 제한적이었으나 노드는 권한을 가지고 있음 

**파일 읽기 예제**

```javascript
const fs = require('fs');

fs.readFile('./readme.txt', (err, data) => {
  if (err) {
    throw err;
  }
  console.log(data);
  console.log(data.toString());
});
```
- `toString` 메서드를 사용하는 이유는 `data`가 버퍼이기 때문이다.

fs는 기본적으로 콜백 형식의 모듈이라 사용하기 불편하다. `promises` 속성을 불러오면 프로미스 기반의 fs 모듈을 사용할 수 있게 된다. 

```javascript
const fs = require('fs').promises;

fs.readFile('./readme.txt')
  .then((data) => {
    console.log(data);
    console.log(data.toString());
  })
  .catch((err) => {
    console.error(err);
  });
```

<br>

### 동기 메서드와 비동기 메서드

`setTimeout`, `process.nextTick` 외에도 노드는 대부분의 메서드를 비동기 방식으로 처리한다. 하지만 몇몇 메서드는 동기 방식으로도 사용할 수 있다. 특히 fs 모듈이 그러한 메서드를 많이 갖고 있다. 
- 동기 메서드들은 이름 뒤에 `Sync`가 붙어 있어 구분하기 쉽다. 대부분의 경우에 비동기 메서드가 훨씬 더 효율적이기 때문에 동기 메서드는 프로그램을 처음 실행할 때 초기화 용도로만 사용하는 것을 권장한다.

비동기 메서드는 코드의 순서와 실행 순서가 일치하지 않는다. 비동기 방식으로 하되 순서를 유지하고 싶다면 어떻게 해야 할까? 이전 `readFile`의 콜백에 다음 `readFile`을 넣으면 된다. 이른바 '콜백 지옥'이 펼쳐지지만 적어도 순서가 어긋나는 일은 없다. 

> #### 동기와 비동기, 블로킹과 논블로킹 
> - **동기와 비동기**: 백그라운드 작업 완료 계속 확인하고, 안 하고 
> - **블로킹과 논블로킹**: 함수가 바로 return되지 않고, 되고
> 
> 노드에서는 동기-블로킹 방식과 비동기-논블로킹 방식이 대부분이다. 

<br>

### 버퍼와 스트림 이해하기 

파일을 읽거나 쓰는 방식에는 크게 두 가지 방식, 즉 버퍼를 이용하거나 스트림을 이용하는 방식이 있다. 

> 버퍼는 일정한 크기로 모아두는 데이터로, 일정한 크기가 되면 한번에 처리한다.
>  스트림은 데이터의 흐름으로, 일정한 크기로 나눠서 여러 번에 걸쳐서 처리한다.

노드는 파일을 읽을 때 메모리에 파일 크기만큼 공간을 마련해두며 파일 데이터를 메모리에 저장한 뒤 사용자가 조작할 수 있도록 한다. 이때 메모리에 저장된 데이터가 바로 버퍼이다. `readFile` 방식의 버퍼가 편리하기는 하지만 문제점도 있다. 
- 메모리에 파일 크기만큼 버퍼를 만들어야 하므로 서버처럼 몇 명이 이용할지 모르는 환경에서는 메모리 문제가 발생할 수 있다.
- 모든 내용을 버퍼에 다 쓴 후에야 다음 동작으로 넘어가므로 매번 전체 용량을 버퍼로 처리해야 다음 단계로 넘어갈 수 있다.

그래서 버퍼의 크기를 작게 만들고 여러 번에 걸쳐 나눠 보내는 방식이 등장했다. 이를 편리하게 만든 것이 스트림이다. 

스트림끼리 연결하는 것을 '파이핑한다'고 표현한다. `pipe`는 스트림 사이에 여러 번 연결할 수 있다. 
- 예시로, 미리 읽기, 쓰기 스트림을 만들어둔 후 두 스트림 사이를 `pipe` 메서드로 연결하면 저절로 데이터가 넘어간다. 

<br>

### 참고

Node.js 교과서 - 기본부터 프로젝트 실습까지
