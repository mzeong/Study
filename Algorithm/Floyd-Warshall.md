### Floyd-Warshall

- **모든 정점 쌍 사이의** 최단 거리를 $O(n^3)$에 구하는 알고리즘 

$O(n^3)$이지만 단순 사칙연산이 주를 이루기 때문에 **정점 1000개 정도까지는 플로이드-워셜로 풀어볼 만하다.** 따라서 주어진 그래프 문제에서 정점의 수가 1000개 이하로 작다면 일단 플로이드-워셜을 돌릴 수 있음을 인지하고, 모든 정점 쌍 사이의 최단 경로를 구할 경우 문제에서 요구하는 바를 계산해낼 수 있는지를 고민하는 식으로 접근하면 된다.

#### 구현

```c++
for(int k = 1; k <= n; k++){
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);
        }
    }
}
```

- 테이블을 갱신할 때 중간에 거쳐 가게끔 할 원소를 **3중 for문의 제일 바깥에** 두어야 한다.
- 계산 과정에서 INF값 2개를 더할 때 int overflow가 나지 않게 주의해야 한다. 
- `if(dist[i][k] + dist[k][j] < dist[i][j]) dist[i][j] = dist[i][k] + dist[k][j]`로 작성해 **갱신이 꼭 필요할 때에만 대입이 일어나도록 하는 게 시간상 유리하다.** 다른 문제들처럼 끽해야 대입을 10만 번, 100만 번 하는 수준에서는 차이가 미미하지만 특히 플로이드-워셜처럼 대입을 10억 번씩 하는 경우에는 차이가 눈에 띄게 커진다. 
	- 그러나 보통 상수 시간의 차이로 문제가 틀리는 경우가 안 생기게 시간 제한을 적당히 넉넉하게 준다. (보통 플로이드-워셜이 정해라면 정점을 최대 1000개씩 주는 건 썩 바람직한 상황이 아니다.)

<br>

### 참고

BaaaaaaaarkingDog 실전 알고리즘
