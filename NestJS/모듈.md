### 모듈

- 조그만 클래스나 함수처럼 한 가지 일만 수행하는 소프트웨어 컴포넌트가 아니라, 여러 컴포넌트를 조합하여 좀 더 큰 작업을 수행할 수 있게 하는 단위

Nest 애플리케이션이 실행되기 위해서는 하나의 루트 모듈이 존재하고 이 루트 모듈(일반적으로 AppModule)은 다른 모듈들로 구성된다. 이렇게 모듈로 쪼개는 이유는 여러 모듈에 각기 맡은 바 책임을 나누고 응집도를 높이기 위함이다.

모듈은 `@Module` 데커레이터를 사용한다. `@Module` 데커레이터의 인수로 <ins>ModuleMetadata</ins>를 받는다. 
- imports: 이 모듈에서 사용하기 위한 프로바이더를 가지고 있는 다른 모듈을 가져온다. 
- controllers/providers: 모듈 전반에서 컨트롤러와 프로바이더를 사용할 수 있도록 Nest가 객체를 생성하고 주입할 수 있게 해준다.
- exports: 이 모듈에서 제공하는 컴포넌트를 다른 모듈에서 import해서 사용하고자 한다면 export를 해야 한다. export로 선언했다는 뜻은 어디에서나 가져다 쓸 수 있으므로 public 인터페이스 또는 API로 간주된다. 

> 모듈은 프로바이더처럼 주입해서 사용할 수 없다. 모듈 간 순환 종속성이 발생하기 때문이다.

<br>

### 전역 모듈 

Nest는 모듈 범위 내에서 프로바이더를 캡슐화한다. 따라서 어떤 모듈에 있는 프로바이더를 사용하려면 모듈을 먼저 가져와야 한다. 
하지만 헬퍼와 같은 공통 기능이나 DB 연결과 같은 전역적으로 쓸 수 있어야 하는 프로바이더가 필요한 경우가 있다. 이런 프로바이더를 모아 전역 모듈로 제공하면 된다. 

전역 모듈을 만드는 방법은 `@Global` 데커레이터만 선언하면 된다. 전역 모듈은 루트 모듈이나 코어 모듈에서 한 번만 등록해야 한다. 

> 모듈은 응집도를 높이기 위함이라 했는데 모든 것을 전역으로 만들면 기능이 어디에나 존재하게 된다는 뜻이므로 응집도가 떨어지게 될 것이다. 꼭 필요한 기능만 모아 전역 모듈로 사용해야 한다. 

<br>

### 참고

NestJS로 배우는 백엔드 프로그래밍
