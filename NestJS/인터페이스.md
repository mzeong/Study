<h3>인터페이스</h3>

- <b>컨트롤러</b>는 들어오는 요청을 받고 처리된 결과를 응답으로 돌려주는 <U>인터페이스 역할</U>을 한다. 
- 서버에서 제공하는 기능을 어떻게 클라이언트와 주고받을지에 대한 인터페이스를 정의하고 데이터의 구조를 기술한다. 

<br>
<h3>요청 객체</h3>

- 클라이언트는 요청을 보내면서 종종 서버가 원하는 정보를 함께 전송한다. Nest는 요청과 함께 전달되는 데이터를 핸들러가 다룰 수 있는 객체로 변환한다. 이렇게 변환된 객체는 `@Req` 데커레이터를 이용하여 다룰 수 있다. 이 요청 객체는 HTTP 요청을 나타낸다. 
- API를 작성할 때 요청 객체를 직접 다루는 경우는 드물다. Nest는 `@Query()`, `@Param(key?: string)`, `@Body()` 데커레이터를 이용해서 요청에 포함된 쿼리 매개변수, 패스(경로) 매개변수, 본문을 쉽게 받을 수 있게 해준다. 

<br>
<h3>응답</h3>

- CRUD에 대해 성공 응답으로 POST는 201, 그 외는 200을 보낸다. 
- 만약 상태 코드를 다른 값으로 바꾸길 원한다면 `@HttpCode` 데커레이터로 손쉽게 적용할 수 있다. 
- Nest는 응답을 어떤 방식으로 처리할 지 미리 정의해뒀다. string, number, boolean과 같이 자바스크립트 원시 타입을 리턴할 경우 직렬화 없이 바로 보내지만, <U>객체를 리턴한다면 직렬화를 통해 JSON으로 자동 변환해준다.</U>

<br>
<h3>헤더</h3>

- Nest는 응답 헤더 역시 자동 구성해준다.
- 만약 응답에 커스텀 헤더를 추가하고 싶다면 `@Header` 데커레이터를 사용하면 된다. 인수로 헤더 이름과 값을 받는다. 

<br>
<h3>리디렉션</h3>

- 서버가 요청을 처리한 후, 요청을 보낸 클라이언트를 다른 페이지로 이동하고 싶은 경우를 리디렉션이라 한다. 
- `@Redirect` 데커레이터를 사용하면 쉽게 구현이 가능하다. 
- 데커레이터의 두 번째 인수는 상태 코드이다. 이 상태 코드를 200과 같이 다른 것으로 바꾸어 응답할 수 있지만, 301, 307, 308과 같이 Redirect로 정해진 응답 코드가 아닐 경우 브라우저가 제대로 반응하지 않을 수 있다. 

<br>
<h3>라우트 매개변수</h3>

- 경로를 구성하는 매개변수로, 패스 매개변수라고도 한다. 
- 전달받은 매개변수는 함수 인수에 `@Param` 데커레이터로 주입받을 수 있다. 
> 매개변수가 여러 개 전달될 경우, <U>객체로 한 번에 받는 방법은</U> params의 타입이 any가 되어 <U>권장하지 않는다.</U> 물론 라우트 매개변수는 타입이 항상 string이기 때문에 명시적으로 { [key: string]: string } 타입을 지정해도 된다. 
> `deleteUserMemo(@Param() params: { [key: string]: string })`
> 
> 더 일반적인 방법은 아래 코드처럼 라우팅 매개변수를 따로 받는 것이다. REST API를 구성할 때는 라우팅 매개변수의 개수가 너무 많아지지 않게 설계하는 것이 좋기 때문에 따로 받아도 코드가 많이 길어지지는 않는다.
> `deleteUserMemo(@Param('userId') userId: string, @Param('memoId') memoId: string)`

<br>
<h3>하위 도메인 라우팅</h3>

서버에서 제공하는 기능을 API로 외부에 공개하기로 했다고 가정하자. 현재 회사가 사용하고 있는 도메인은 example.com이고, API 요청은 api.example.com으로 받기로 했다. 즉, http://example.com, http://api.example.com로 들어온 요청을 서로 다르게 처리하고 싶다. 또한, 하위 도메인에서 처리하지 못하는 요청은 원래의 도메인에서 처리되도록 하고 싶다고 하자. 이런 경우 하위 도메인 라우팅 기법을 쓸 수 있다.

1. 새로운 컨트롤러를 생성한다. 
	`$ nest g co Api`
	
2. ApiController에서도 같은 엔드포인트를 받을 수 있도록 하기 위해 ApiController가 먼저 처리되도록 순서를 수정한다. 

```
@Module({
	controllers: [ApiController, AppController],
	...
})
export class AppModule { }
```

3. `@Controller` 데커레이터는 ControllerOptions 객체를 인수로 받는데, host 속성에 하위 도메인을 기술하면 된다. 
```
@Controller({ host: 'api.example.com' }) //하위 도메인 요청 처리 설정
export class ApiController {
	@Get() //같은 루트 경로
	index(): string {
		return 'Hello, API'; //다른 응답
	}
}
```
4. 이제 각각 GET 요청을 보내면 응답을 다르게 주는 것을 볼 수 있다. 

<br>

앞서 요청 패스를 `@Param` 데커레이터로 받아 동적으로 처리한 것과 유사하게 `@HostParam` 데커레이터를 이용하면 <U>서브 도메인을 변수로 받을 수 있다.</U> 
- API 버저닝을 하는 방법은 여러 가지가 있지만 하위  도메인을 이용하는 방법을 많이 사용한다. 하위 도메인 라우팅으로 쉽게 API를 버전별로 분리할 수 있다. 

host param이 없는 host로 요청을 하면 기존 도메인으로 요청이 처리되는 것을 볼 수 있다. 

<br>
<h3>페이로드 다루기</h3>

- POST, PUT, PATCH 요청은 보통 처리에 필요한 데이터를 함께 실어 보낸다. 이 데이터 덩어리, 즉 페이로드를 본문이라고 한다. 
- Nest에는 데이터 전송 객체(DTO)가 구현되어 있어 본문을 쉽게 다룰 수 있다. 

<br>
<h3>참고</h3>

NestJS로 배우는 백엔드 프로그래밍
